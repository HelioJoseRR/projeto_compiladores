# Tutorial: Como Converter TAC em Assembly ARMv7

## 1. **Introdução**
Este tutorial explica passo a passo como transformar um código intermediário em TAC (Three-Address Code) para assembly ARMv7, seguindo padrões de compiladores e usando convenções de chamada ARM (AAPCS). As explicações são detalhadas, com exemplos práticos e instruções claras para cada etapa.

## 2. **Preparação Inicial**
- Certifique-se de entender o formato do TAC. Cada linha representa uma operação, por exemplo:
  - Atribuições simples: `a = 10`
  - Operações aritméticas: `t1 = a + b`
  - Controle de fluxo: `LABEL`, `GOTO`, `IF_FALSE`, `IF_TRUE`
  - Chamadas de função: `CALL`, `PARAM`, `RETURN`, `FUNC_BEGIN`, `FUNC_END`

**Exemplo TAC:**
```
 0: num = 10
 1: FUNC_BEGIN count
 2: PARAM n
 3: LABEL L0
 4: t0 = n >= 0
 5: IF_FALSE t0 GOTO L1
 6: PARAM n
 7: CALL print 1 t1
 8: t2 = n - 1
 9: n = t2
10: GOTO L0
11: LABEL L1
12: FUNC_END count
13: PARAM num
14: CALL count 1 t3
```

## 3. **Passo 1: Identificação de Variáveis Globais**
Variables atribuídas fora de funções são globais na maioria das gerações de código. Gere uma seção `.data` para elas:
```armv7
    .data
num:    .word 10
```

## 4. **Passo 2: Estrutura Básica do Assembly**
Monte o esqueleto do Assembly:
```armv7
    .text
    .global main
    .align 2
```
O `main` serve como ponto inicial de execução.

## 5. **Passo 3: Tradução de Funções**
Cada função no TAC é implementada como um label. Use prólogo e epílogo padrão:
```armv7
count:
    push {r4, lr}      @ salva registradores callee-save
    ...                @ corpo da função
    pop {r4, lr}
    bx lr              @ retorna da função
```

## 6. **Passo 4: Tradução de Parâmetros**
Por convenção AAPCS, os 4 primeiros parâmetros vão em `r0` a `r3`. Exemplo de chamada:
```armv7
    ldr r0, =num       @ carrega valor inicial de num para r0
    ldr r0, [r0]
    bl count           @ chama função count(n=num)
```
Na função:
```armv7
    mov r4, r0         @ copia parâmetro n para r4
```

## 7. **Passo 5: Controle de Fluxo**
Traduza labels, saltos e condições:
- `LABEL`: vira um label no assembly
- `GOTO`: vira `b label`
- `IF_FALSE t0 GOTO L1`: use `cmp` e desvio condicional
```armv7
L0:
    cmp r4, #0         @ compara n >= 0
    blt L1             @ se n < 0, vai para L1
```

## 8. **Passo 6: Operações Aritméticas e Atribuições**
- `t2 = n - 1` vira `sub r5, r4, #1` (supondo r5 para t2)
- `n = t2` vira `mov r4, r5`

## 9. **Passo 7: Chamada de Função**
- Chame funções com `bl nome_funcao`, passando argumentos nos registradores conforme necessário.
- Exemplo:
```armv7
    mov r0, r4         @ PARAM n
    bl print           @ CALL print(n)
```

## 10. **Passo 8: Loop e Saída**
Implemente loops e finalização conforme o TAC:
```armv7
    sub r4, r4, #1     @ n = n - 1
    b L0               @ loop
L1:
    pop {r4, lr}
    bx lr
```

## 11. **Código Assembly ARMv7 Final para o Exemplo**
```armv7
    .data
num:    .word 10

    .text
    .global main
    .align 2

main:
    push {r4, lr}
    ldr r0, =num
    ldr r0, [r0]
    bl count
    mov r0, #0
    pop {r4, lr}
    bx lr

count:
    push {r4, lr}
    mov r4, r0
L0:
    cmp r4, #0
    blt L1
    mov r0, r4
    bl print
    sub r4, r4, #1
    b L0
L1:
    pop {r4, lr}
    bx lr

print:
    push {lr}
    @ imprimir valor em r0 (implemente conforme seu sistema)
    pop {lr}
    bx lr
    .end
```

## 12. **Boas Práticas e Otimizações**
- Prefira manter variáveis vivas em registradores para eficiência. Salve na memória só antes de calls ou saltos, se necessário. ("Se c está em memória e Ri contém b, o código ótimo: LOAD b, RO; ADD c, RO; STO RO, a." )[1]
- Use análise de próximo-uso: mantenha valor em registrador se será usado logo após. ("Uma variável está viva numa linha i desse bloco se ela vai ser subsequentemente usada nesse bloco." )[1]
- Libere registradores que não guardam valores vivos após uso.

## 13. **Fontes e Referências**
> “Para cada operador do código intermediário existe um operador no código objeto, resultados computados podem ser deixados em registradores tanto tempo quanto desejado, salvando-os somente se o registrador for necessário imediatamente antes de uma chamada de procedure, desvio ou comando com rótulo…”[1]

> “O algoritmo de geração de código manipula descritores que informam o que contém cada registrador. Inicialmente, todos os registradores estão vazios. O descritor de endereços informa onde o valor da variável pode ser encontrado; a localização pode ser registrador, endereço de memória ou pilha…”[1]



other examples: 
Segue a tradução do seu código TAC para um assembly ARMv7 funcional, usando convenção AAPCS e comentários para cada etapa do processo

---------------------------------------------------------------------------------------------------------------------------------------

    .data
num:    .word 10           @ variável global num = 10

    .text
    .global main
    .align 2

main:
    push {r4, lr}          @ preserva registradores essenciais

    ldr r0, =num           @ carrega endereço de num
    ldr r0, [r0]           @ carrega valor de num em r0
    bl count               @ chama função count(n=num)

    mov r0, #0             @ retorna 0
    pop {r4, lr}
    bx lr

count:
    push {r4, r5, lr}      @ prólogo, preserva r4/r5/lr
    mov r4, r0             @ n começa em r4

L0:
    cmp r4, #0             @ t0 = n >= 0?
    blt L1                 @ IF_FALSE t0 GOTO L1 (se n < 0)

    mov r0, r4             @ PARAM n para print
    bl print               @ CALL print(n)

    sub r4, r4, #1         @ t2 = n - 1; n = t2
    b L0                   @ GOTO L0 (repete loop)

L1:
    pop {r4, r5, lr}       @ epílogo, restaura registradores
    bx lr                  @ retorna para função chamadora

print:
    push {lr}              @ salva lr
    @ Implemente aqui sua lógica de impressão (exemplo syscall, externo, etc)
    pop {lr}
    bx lr

    .end




-------------------------------------------------------------------------------------------




    .data
a:      .word 10                @ variável global a = 10
b:      .word 1                 @ variável global b = true (1)
s:      .word 0                 @ variável global s

    .text
    .global main
    .align 2

main:
    push {r4, lr}               @ salva registradores
    
    mov r0, #2                   @ PARAM 2 (primeiro argumento)
    mov r1, #3                   @ PARAM 3 (segundo argumento)
    bl soma                      @ CALL soma 2 t6
    
    mov r4, r0                   @ salva resultado em r4 (t6)
    mov r0, r4                   @ PARAM t6
    bl print                     @ CALL print 1 t7
    
    mov r0, #0                   @ retorna 0
    pop {r4, lr}
    bx lr

soma:
    push {r4, r5, r6, lr}       @ salva registradores (FUNC_BEGIN)
    mov r4, r0                   @ salva num1 em r4
    mov r5, r1                   @ salva num2 em r5
    
    add r6, r4, r5               @ t0 = num1 + num2
    ldr r0, =s                   @ carrega endereço de s
    str r6, [r0]                @ s = t0

L0:
    ldr r0, =a                   @ carrega endereço de a
    ldr r1, [r0]                @ carrega valor de a
    cmp r1, #20                  @ t1 = a < 20
    bge L1                       @ IF_FALSE t1 GOTO L1
    
    add r1, r1, #1               @ t2 = a + 1
    ldr r0, =a                   @ carrega endereço de a
    str r1, [r0]                @ a = t2
    
    mov r0, r1                   @ PARAM a
    bl print                     @ CALL print 1 t3
    
    ldr r0, =a                   @ carrega endereço de a
    ldr r1, [r0]                @ carrega valor de a
    cmp r1, #15                  @ t4 = a == 15
    bne L2                       @ IF_FALSE t4 GOTO L2
    
    b L1                         @ GOTO L1

L2:
    b L0                         @ GOTO L0

L1:
    ldr r0, =s                   @ carrega endereço de s
    ldr r1, [r0]                @ carrega valor de s
    add r0, r1, #10              @ t5 = s + 10
                                 @ RETURN t5 (resultado já está em r0)
    pop {r4, r5, r6, lr}        @ restaura registradores (FUNC_END)
    bx lr                        @ retorna da função

print:
    push {lr}
    
    @ Implementação da função print
    @ Aqui você pode adicionar código para imprimir o valor em r0
    @ Exemplo usando syscall Linux ARM:
    @ mov r7, #4                 @ syscall write
    @ mov r2, #1                 @ tamanho
    @ svc #0                     @ chamada de sistema
    
    pop {lr}
    bx lr

    .end

